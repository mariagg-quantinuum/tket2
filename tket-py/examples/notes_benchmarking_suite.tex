# Insert/replace these imports near the top of your file
from pytket.passes import FullPeepholeOptimise
# (other imports remain the same)

# ---------------------------
# Build gadget instances & optimiser
# ---------------------------
GADGET_INSTANCES = [
    ZZPhaseFlip(),
    CXGadget(),
    Squash3Gadget(),
    LabelGadget(),
    KAKGadget(),
]
GADGET_NAMES = [g.__class__.__name__ for g in GADGET_INSTANCES]

OPTIMISER = BadgerOptimiser(GADGET_INSTANCES)

# ---------------------------
# Helper: try to apply a gadget in a robust way
# ---------------------------
def _try_apply_gadget(gadget, tk2_circ):
    """
    Attempt to apply a gadget to a Tk2Circuit using a sequence of likely method names.
    If the gadget returns a new circuit, that is used. If it modifies in-place, the
    original object is used. Raises AttributeError if no known method exists.
    """
    # Candidate method names (ordered by likelihood)
    try_methods = ("apply", "rewrite", "run", "rewrite_tk2", "rewrite_circuit", "transform")

    for m in try_methods:
        if hasattr(gadget, m):
            func = getattr(gadget, m)
            res = func(tk2_circ)
            # if the method returns something (new circuit), use it, otherwise assume in-place
            return tk2_circ if res is None else res

    # Final fallback: if gadget is callable, call it
    if callable(gadget):
        res = gadget(tk2_circ)
        return tk2_circ if res is None else res

    raise AttributeError(f"No known apply/rewrite/run interface for gadget {gadget!r}")

# ---------------------------
# Benchmark function (with per-gadget timing + peephole)
# ---------------------------
def benchmark_generator(name: str, generator: Callable[[], Circuit], n_samples: int = N_SAMPLES):
    """
    For each generated circuit:
      - Run DecomposeBoxes + AutoRebase
      - Measure original 2Q gates
      - (A) Run OPTIMISER.optimise(...) (timed) -> measure opt_2q
      - (B) On a separate copy, apply gadgets sequentially using _try_apply_gadget to
            collect per-gadget times and 2Q reductions
      - Apply FullPeepholeOptimise() to the optimiser result and measure final 2Q
    Returns aggregated metrics across n_samples.
    """
    total_opt_time = 0.0
    total_peephole_time = 0.0

    orig_2q_total = 0
    opt_2q_total = 0
    peephole_2q_total = 0

    # accumulate gadget metrics (over all samples)
    gadget_time_totals = {n: 0.0 for n in GADGET_NAMES}
    gadget_2q_reduction = {n: 0 for n in GADGET_NAMES}
    gadget_failures = {n: 0 for n in GADGET_NAMES}

    for _ in tqdm(range(n_samples), desc=f"Benchmarking {name}"):
        # generate and preprocess
        circ = generator()
        DecomposeBoxes().apply(circ)
        AutoRebase({OpType.CX, OpType.Rz, OpType.Rx}).apply(circ)

        # record original 2Q count
        orig_2q = circ.n_2qb_gates()
        orig_2q_total += orig_2q

        # -------------------------
        # (A) Run whole-optimiser (works for you)
        # -------------------------
        tk2_for_opt = Tk2Circuit(circ)  # fresh instance for optimiser
        t0 = time.time()
        opt_circ_tk2 = OPTIMISER.optimise(tk2_for_opt)
        t_opt = time.time() - t0
        total_opt_time += t_opt

        # convert to pytket Circuit and measure 2Q gates after optimiser
        opt_circ1 = opt_circ_tk2.to_tket1()
        opt_2q = opt_circ1.n_2qb_gates()
        opt_2q_total += opt_2q

        # -------------------------
        # (B) Per-gadget sequential profiling on a copy of the original circuit
        #     (apply gadgets one-by-one in the same order as GADGET_INSTANCES)
        # -------------------------
        tk2_copy = Tk2Circuit(circ)  # fresh copy to apply gadgets sequentially
        prev_count = orig_2q

        for gname, gadget in zip(GADGET_NAMES, GADGET_INSTANCES):
            try:
                gstart = time.time()
                tk2_copy = _try_apply_gadget(gadget, tk2_copy)
                gtime = time.time() - gstart
                gadget_time_totals[gname] += gtime

                # measure 2Q after this gadget (convert to tket1)
                cur_2q = tk2_copy.to_tket1().n_2qb_gates()
                delta = max(prev_count - cur_2q, 0)
                gadget_2q_reduction[gname] += delta
                prev_count = cur_2q

            except Exception as exc:
                # record failure but continue
                gadget_failures[gname] += 1
                # do not change prev_count or tk2_copy in this case
                continue

        # -------------------------
        # (C) Apply Full Peephole to optimiser result and measure
        # -------------------------
        peephole_pass = FullPeepholeOptimise()
        t0 = time.time()
        peephole_pass.apply(opt_circ1)
        t_peep = time.time() - t0
        total_peephole_time += t_peep

        peephole_2q = opt_circ1.n_2qb_gates()
        peephole_2q_total += peephole_2q

    # -------------------------
    # Summarise aggregated results
    # -------------------------
    reduction_total = orig_2q_total - opt_2q_total
    pct_reduction = 100.0 * reduction_total / orig_2q_total if orig_2q_total > 0 else 0.0
    avg_opt_time = total_opt_time / n_samples
    avg_peephole_time = total_peephole_time / n_samples

    # gadget time percentages (normalised over total gadget time collected)
    total_gadget_time_collected = sum(gadget_time_totals.values())
    gadget_percentages = {
        g: (100.0 * t / total_gadget_time_collected) if total_gadget_time_collected > 0 else 0.0
        for g, t in gadget_time_totals.items()
    }

    # gadget contribution to 2Q reduction (percentage of original total 2Q gates)
    gadget_2q_pct = {
        g: (100.0 * red / orig_2q_total) if orig_2q_total > 0 else 0.0
        for g, red in gadget_2q_reduction.items()
    }

    return {
        "name": name,
        "orig_2q": orig_2q_total,
        "opt_2q": opt_2q_total,
        "peephole_2q": peephole_2q_total,
        "reduction": reduction_total,
        "pct_reduction": pct_reduction,
        "total_opt_time": total_opt_time,
        "avg_opt_time": avg_opt_time,
        "total_peephole_time": total_peephole_time,
        "avg_peephole_time": avg_peephole_time,
        "gadget_times": gadget_time_totals,
        "gadget_percentages": gadget_percentages,
        "gadget_2q_reduction": gadget_2q_reduction,
        "gadget_2q_pct": gadget_2q_pct,
        "gadget_failures": gadget_failures,
    }

# ---------------------------
# Main loop (unchanged caller pattern)
# ---------------------------
if __name__ == "__main__":
    results: List[Dict] = []

    print(f"\nRunning benchmarking suite on {len(GENERATORS)} circuit types (with gadget profiling)...")
    for name, gen in GENERATORS.items():
        res = benchmark_generator(name, gen, N_SAMPLES)
        results.append(res)

    # Print summary including gadget timing
    print("\n=== BENCHMARK SUMMARY (WITH GADGET PROFILING + PEEPHOLE) ===")
    for r in results:
        print(
            f"{r['name']:<35s} "
            f"2Q Gates: {r['orig_2q']:>6d} → {r['opt_2q']:>6d} "
            f"({r['pct_reduction']:.2f}% gadget reduction) → {r['peephole_2q']:>6d} after peephole | "
            f"Avg Optimiser Time: {r['avg_opt_time']*1000:.2f} ms | Avg Peephole: {r['avg_peephole_time']*1000:.2f} ms"
        )
        print("  Gadget time distribution (percent of collected gadget time):")
        for g in GADGET_NAMES:
            print(f"    {g:<15s}: {r['gadget_percentages'][g]:6.2f}%  | 2Q reduction: {r['gadget_2q_reduction'][g]:>6d} ({r['gadget_2q_pct'][g]:5.2f}%)  failures: {r['gadget_failures'][g]}")
        print()

    total_time = sum(r["total_opt_time"] + r["total_peephole_time"] for r in results)
    print(f"\nTotal runtime for all benchmarks (optimiser + peephole): {total_time:.2f} s")
